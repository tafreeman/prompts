{
  "run_id": "fullstack_generation-4d4f0338",
  "workflow_name": "fullstack_generation",
  "status": "success",
  "success_rate": 85.71428571428571,
  "total_duration_ms": 62009.577999999994,
  "total_retries": 0,
  "step_count": 7,
  "failed_step_count": 0,
  "start_time": "2026-02-08T21:32:31.121361+00:00",
  "end_time": "2026-02-08T21:33:33.130939+00:00",
  "dataset": {
    "source": "local",
    "dataset_id": "agentic-workflows-v2/tests/fixtures/datasets/code_instructions_120k.json",
    "dataset_path": "agentic-workflows-v2/tests/fixtures/datasets/code_instructions_120k.json",
    "sample_index": 1,
    "task_id": "1",
    "dataset_workflow_compatible": true,
    "dataset_mismatch_reasons": []
  },
  "inputs": {
    "feature_spec": "Below is an instruction that describes a task. Write a response that appropriately completes the request.\n\n### Instruction:\nDevelop a function that will add two strings\n\n### Input:\nstr1 = \"Hello \"\nstr2 = \"world\"\n\n### Response:\ndef add_strings(str1, str2):\n    \"\"\"This function takes two strings and returns the sum of them.\"\"\"\n    return str1 + str2\n\nstr1 = \"Hello \"\nstr2 = \"world\"\nsum_of_strings = add_strings(str1, str2)",
    "tech_stack": {
      "frontend": "react",
      "backend": "fastapi",
      "database": "postgresql"
    }
  },
  "steps": [
    {
      "step_name": "design_architecture",
      "status": "success",
      "agent_role": null,
      "tier": 3,
      "model_used": "gemini:gemini-2.5-flash",
      "duration_ms": 18098.856,
      "retry_count": 0,
      "tokens_used": 1170,
      "input": {},
      "output": {
        "raw_response": "{\n  \"api_spec\": {\n    \"endpoints\": [\n      {\n        \"path\": \"/strings/add\",\n        \"method\": \"POST\",\n        \"summary\": \"Concatenate two strings\",\n        \"description\": \"Accepts two strings as input and returns their concatenation. This endpoint implements the 'add two strings' function.\",\n        \"request_body\": {\n          \"description\": \"Payload containing two strings to be concatenated.\",\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"type\": \"object\",\n                \"properties\": {\n                  \"str1\": {\n                    \"type\": \"string\",\n                    \"description\": \"The first string for concatenation.\"\n                  },\n                  \"str2\": {\n                    \"type\": \"string\",\n                    \"description\": \"The second string for concatenation.\"\n                  }\n                },\n                \"required\": [\"str1\", \"str2\"]\n              }\n            }\n          }\n        },\n        \"responses\": {\n          \"200\": {\n            \"description\": \"Successfully concatenated strings.\",\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"type\": \"object\",\n                  \"properties\": {\n                    \"result\": {\n                      \"type\": \"string\",\n                      \"description\": \"The concatenated string.\"\n                    }\n                  }\n                }\n              }\n            }\n          },\n          \"400\": {\n            \"description\": \"Invalid input provided (e.g., non-string values or missing parameters).\"\n          },\n          \"500\": {\n            \"description\": \"Internal server error.\"\n          }\n        }\n      }\n    ]\n  },\n  \"db_schema\": {\n    \"tables\": []\n  },\n  \"component_tree\": {\n    \"frontend\": {\n      \"name\": \"React Application\",\n      \"description\": \"The user interface built with React, responsible for collecting string inputs and displaying the concatenation result.\",\n      \"components\": [\n        {\n          \"name\":"
      },
      "error": null,
      "error_type": null,
      "start_time": "2026-02-08T21:32:31.121749+00:00",
      "end_time": "2026-02-08T21:32:49.220605+00:00",
      "metadata": null
    },
    {
      "step_name": "generate_api",
      "status": "success",
      "agent_role": null,
      "tier": 2,
      "model_used": "gemini:gemini-2.0-flash",
      "duration_ms": 4563.525000000001,
      "retry_count": 0,
      "tokens_used": 1563,
      "input": {},
      "output": {
        "api_code": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass StringInput(BaseModel):\n    str1: str\n    str2: str\n\nclass StringOutput(BaseModel):\n    result: str\n\n@app.post(\"/strings/add\", response_model=StringOutput, summary=\"Concatenate two strings\", description=\"Accepts two strings as input and returns their concatenation. This endpoint implements the 'add two strings' function.\")\nasync def add_strings(string_input: StringInput):\n    \"\"\"Concatenates two strings and returns the result.\"\"\"\n    try:\n        result = string_input.str1 + string_input.str2\n        return StringOutput(result=result)\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n",
        "api_tests": "from fastapi.testclient import TestClient\nfrom main import app  # Assuming your FastAPI app is in main.py\n\nclient = TestClient(app)\n\ndef test_add_strings_success():\n    response = client.post(\"/strings/add\", json={\"str1\": \"Hello \", \"str2\": \"world\"})\n    assert response.status_code == 200\n    assert response.json() == {\"result\": \"Hello world\"}\n\ndef test_add_strings_empty_strings():\n    response = client.post(\"/strings/add\", json={\"str1\": \"\", \"str2\": \"\"})\n    assert response.status_code == 200\n    assert response.json() == {\"result\": \"\"}\n\ndef test_add_strings_with_numbers():\n     response = client.post(\"/strings/add\", json={\"str1\": \"123\", \"str2\": \"456\"})\n     assert response.status_code == 200\n     assert response.json() == {\"result\": \"123456\"}\n\ndef test_add_strings_missing_parameter():\n    response = client.post(\"/strings/add\", json={\"str1\": \"test\"})\n    assert response.status_code == 422 #Unprocessable Entity\n"
      },
      "error": null,
      "error_type": null,
      "start_time": "2026-02-08T21:32:49.220730+00:00",
      "end_time": "2026-02-08T21:32:53.784255+00:00",
      "metadata": null
    },
    {
      "step_name": "generate_migrations",
      "status": "success",
      "agent_role": null,
      "tier": 1,
      "model_used": "gh:openai/gpt-4o-mini",
      "duration_ms": 5262.165999999999,
      "retry_count": 0,
      "tokens_used": 1245,
      "input": {},
      "output": {
        "migrations": [
          {
            "migration_name": "create_strings_table",
            "description": "Creates a table for storing strings if needed in the future.",
            "up": [
              {
                "command": "CREATE TABLE strings (",
                "parameters": [
                  "id SERIAL PRIMARY KEY",
                  "str1 VARCHAR(255)",
                  "str2 VARCHAR(255)",
                  "result VARCHAR(255)"
                ],
                "command_end": ");"
              }
            ],
            "down": [
              {
                "command": "DROP TABLE IF EXISTS strings;"
              }
            ]
          }
        ]
      },
      "error": null,
      "error_type": null,
      "start_time": "2026-02-08T21:32:49.220887+00:00",
      "end_time": "2026-02-08T21:32:54.483053+00:00",
      "metadata": null
    },
    {
      "step_name": "generate_frontend",
      "status": "success",
      "agent_role": null,
      "tier": 2,
      "model_used": "gemini:gemini-2.0-flash",
      "duration_ms": 9875.373,
      "retry_count": 0,
      "tokens_used": 2486,
      "input": {},
      "output": {
        "ui_code": {
          "StringAdder.jsx": "import React, { useState } from 'react';\n\nfunction StringAdder() {\n  const [str1, setStr1] = useState('');\n  const [str2, setStr2] = useState('');\n  const [result, setResult] = useState('');\n  const [error, setError] = useState('');\n\n  const handleSubmit = async (event) => {\n    event.preventDefault();\n\n    try {\n      const response = await fetch('/strings/add', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ str1, str2 }),\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json();\n        setError(errorData.detail || 'An error occurred');\n        setResult('');\n        return;\n      }\n\n      const data = await response.json();\n      setResult(data.result);\n      setError('');\n    } catch (err) {\n      setError(err.message || 'An unexpected error occurred');\n      setResult('');\n    }\n  };\n\n  return (\n    <div>\n      <form onSubmit={handleSubmit}>\n        <div>\n          <label htmlFor=\"str1\">String 1:</label>\n          <input\n            type=\"text\"\n            id=\"str1\"\n            value={str1}\n            onChange={(e) => setStr1(e.target.value)}\n          />\n        </div>\n        <div>\n          <label htmlFor=\"str2\">String 2:</label>\n          <input\n            type=\"text\"\n            id=\"str2\"\n            value={str2}\n            onChange={(e) => setStr2(e.target.value)}\n          />\n        </div>\n        <button type=\"submit\">Add Strings</button>\n      </form>\n      {error && <div style={{ color: 'red' }}>Error: {error}</div>}\n      {result && <div>Result: {result}</div>}\n    </div>\n  );\n}\n\nexport default StringAdder;\n",
          "App.jsx": "import React from 'react';\nimport StringAdder from './StringAdder';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <h1>String Adder</h1>\n      <StringAdder />\n    </div>\n  );\n}\n\nexport default App;"
        },
        "ui_tests": {
          "StringAdder.test.jsx": "import React from 'react';\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport StringAdder from './StringAdder';\nimport '@testing-library/jest-dom/extend-expect';\n\n// Mock the fetch function\nglobal.fetch = jest.fn();\n\ndescribe('StringAdder Component', () => {\n  beforeEach(() => {\n    fetch.mockClear();\n  });\n\n  it('renders the component', () => {\n    render(<StringAdder />);\n    expect(screen.getByText('String 1:')).toBeInTheDocument();\n    expect(screen.getByText('String 2:')).toBeInTheDocument();\n    expect(screen.getByText('Add Strings')).toBeInTheDocument();\n  });\n\n  it('updates the input values', () => {\n    render(<StringAdder />);\n    const str1Input = screen.getByLabelText('String 1:');\n    const str2Input = screen.getByLabelText('String 2:');\n\n    fireEvent.change(str1Input, { target: { value: 'Hello' } });\n    fireEvent.change(str2Input, { target: { value: 'World' } });\n\n    expect(str1Input.value).toBe('Hello');\n    expect(str2Input.value).toBe('World');\n  });\n\n  it('submits the form and displays the result', async () => {\n    fetch.mockResolvedValue({\n      ok: true,\n      json: () => Promise.resolve({ result: 'HelloWorld' }),\n    });\n\n    render(<StringAdder />);\n    const str1Input = screen.getByLabelText('String 1:');\n    const str2Input = screen.getByLabelText('String 2:');\n    const addButton = screen.getByText('Add Strings');\n\n    fireEvent.change(str1Input, { target: { value: 'Hello' } });\n    fireEvent.change(str2Input, { target: { value: 'World' } });\n    fireEvent.click(addButton);\n\n    await waitFor(() => {\n      expect(fetch).toHaveBeenCalledTimes(1);\n      expect(fetch).toHaveBeenCalledWith(\n        '/strings/add',\n        {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({ str1: 'Hello', str2: 'World' }),\n        }\n      );\n    });\n\n    await waitFor(() => {\n      expect(screen.getByText('Result: HelloWorld')).toBeInTheDocument();\n    });\n  });\n\n  it('displays an error message when the API returns an error', async () => {\n    fetch.mockResolvedValue({\n      ok: false,\n      json: () => Promise.resolve({ detail: 'Invalid input' }),\n    });\n\n    render(<StringAdder />);\n    const str1Input = screen.getByLabelText('String 1:');\n    const str2Input = screen.getByLabelText('String 2:');\n    const addButton = screen.getByText('Add Strings');\n\n    fireEvent.change(str1Input, { target: { value: 'Invalid' } });\n    fireEvent.change(str2Input, { target: { value: 'Input' } });\n    fireEvent.click(addButton);\n\n    await waitFor(() => {\n      expect(screen.getByText('Error: Invalid input')).toBeInTheDocument();\n    });\n  });\n\n  it('displays a generic error message on network error', async () => {\n    fetch.mockRejectedValue(new Error('Network error'));\n\n    render(<StringAdder />);\n    const str1Input = screen.getByLabelText('String 1:');\n    const str2Input = screen.getByLabelText('String 2:');\n    const addButton = screen.getByText('Add Strings');\n\n    fireEvent.change(str1Input, { target: { value: 'Test' } });\n    fireEvent.change(str2Input, { target: { value: 'Test' } });\n    fireEvent.click(addButton);\n\n    await waitFor(() => {\n      expect(screen.getByText('Error: Network error')).toBeInTheDocument();\n    });\n  });\n});"
        }
      },
      "error": null,
      "error_type": null,
      "start_time": "2026-02-08T21:32:49.220840+00:00",
      "end_time": "2026-02-08T21:32:59.096213+00:00",
      "metadata": null
    },
    {
      "step_name": "generate_integration_tests",
      "status": "success",
      "agent_role": null,
      "tier": 2,
      "model_used": "gh:openai/gpt-4o-mini",
      "duration_ms": 10441.935000000001,
      "retry_count": 0,
      "tokens_used": 6551,
      "input": {},
      "output": {
        "integration_tests": {
          "test_integration_add_strings": {
            "description": "Test the complete integration of the frontend and backend for the string addition functionality.",
            "steps": [
              {
                "step": "Navigate to the string adder page.",
                "expected_result": "The page should load with the string input fields and a submit button."
              },
              {
                "step": "Input 'Hello ' in the first string field.",
                "expected_result": "The first input field should display 'Hello '.",
                "action": {
                  "input_field": "str1",
                  "value": "Hello "
                }
              },
              {
                "step": "Input 'world' in the second string field.",
                "expected_result": "The second input field should display 'world'.",
                "action": {
                  "input_field": "str2",
                  "value": "world"
                }
              },
              {
                "step": "Click the 'Add Strings' button.",
                "expected_result": "The application should send a POST request to '/strings/add' with the input values."
              },
              {
                "step": "Verify the response and display.",
                "expected_result": "The result displayed should be 'Hello world'."
              }
            ],
            "cleanup": {
              "step": "Clear the input fields.",
              "expected_result": "Both input fields should be empty."
            }
          },
          "test_integration_error_handling": {
            "description": "Test how the application handles invalid input or API errors.",
            "steps": [
              {
                "step": "Navigate to the string adder page.",
                "expected_result": "The page should load with the string input fields and a submit button."
              },
              {
                "step": "Input 'Hello ' in the first string field.",
                "expected_result": "The first input field should display 'Hello '.",
                "action": {
                  "input_field": "str1",
                  "value": "Hello "
                }
              },
              {
                "step": "Leave the second string field empty.",
                "expected_result": "The second input field should be empty.",
                "action": {
                  "input_field": "str2",
                  "value": ""
                }
              },
              {
                "step": "Click the 'Add Strings' button.",
                "expected_result": "An error message should be displayed indicating that the second string is required."
              },
              {
                "step": "Input a non-string value like a number.",
                "expected_result": "The input field should accept the value.",
                "action": {
                  "input_field": "str2",
                  "value": "123"
                }
              },
              {
                "step": "Click the 'Add Strings' button.",
                "expected_result": "An error message should be displayed indicating invalid input."
              }
            ]
          }
        }
      },
      "error": null,
      "error_type": null,
      "start_time": "2026-02-08T21:32:59.096463+00:00",
      "end_time": "2026-02-08T21:33:09.538398+00:00",
      "metadata": null
    },
    {
      "step_name": "review_code",
      "status": "success",
      "agent_role": null,
      "tier": 3,
      "model_used": "gemini:gemini-2.5-flash",
      "duration_ms": 23591.618000000002,
      "retry_count": 0,
      "tokens_used": 8783,
      "input": {},
      "output": {
        "raw_response": "```json\n{\n  \"review_report\": {\n    \"backend_code\": {\n      \"status\": \"approved\",\n      \"summary\": \"The FastAPI application correctly implements the string concatenation logic as per the feature specification. Pydantic models are appropriately used for request and response validation, and the API endpoint design is clear. Generic error handling is present, which is a good practice.\",\n      \"details\": [\n        \"Endpoint `/strings/add` with POST method is appropriate.\",\n        \"Pydantic models `StringInput` and `StringOutput` are correctly defined.\",\n        \"String concatenation `string_input.str1 + string_input.str2` is correctly implemented.\",\n        \"General `try...except` block with `HTTPException(status_code=500)` provides a fallback for unexpected errors, though Pydantic handles common validation errors (e.g., missing fields) with 422 automatically.\"\n      ]\n    },\n    \"backend_tests\": {\n      \"status\": \"approved\",\n      \"summary\": \"Comprehensive unit tests are provided for the FastAPI endpoint, covering success cases, empty strings, string representations of numbers, and missing parameters. Tests utilize FastAPI's `TestClient` effectively.\",\n      \"details\": [\n        \"`test_add_strings_success` covers the basic happy path.\",\n        \"`test_add_strings_empty_strings` handles edge cases with empty inputs.\",\n        \"`test_add_strings_with_numbers` correctly verifies that numeric strings are concatenated as strings.\",\n        \"`test_add_strings_missing_parameter` correctly asserts a 422 status code for missing required input, demonstrating proper Pydantic validation handling.\"\n      ]\n    },\n    \"database_migrations\": {\n      \"status\": \"approved_with_note\",\n      \"summary\": \"A database migration to create a `strings` table was generated. While technically correct in its SQL syntax and structure, the necessity of a database for the simple 'add two strings' feature (which does not imply persistence) is questionable for the current minimal requirement. It seems to anticipate future features like logging or storage.\",\n      \"details\": [\n        \"SQL syntax for"
      },
      "error": null,
      "error_type": null,
      "start_time": "2026-02-08T21:33:09.538762+00:00",
      "end_time": "2026-02-08T21:33:33.130380+00:00",
      "metadata": null
    },
    {
      "step_name": "assemble_feature",
      "status": "skipped",
      "agent_role": null,
      "tier": 1,
      "model_used": null,
      "duration_ms": null,
      "retry_count": 0,
      "tokens_used": null,
      "input": {},
      "output": {},
      "error": null,
      "error_type": null,
      "start_time": "2026-02-08T21:33:33.130501+00:00",
      "end_time": null,
      "metadata": {
        "skip_reason": "conditions not met"
      }
    }
  ],
  "final_output": {
    "feature_package": null,
    "review_report": null,
    "all_code": {
      "backend": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass StringInput(BaseModel):\n    str1: str\n    str2: str\n\nclass StringOutput(BaseModel):\n    result: str\n\n@app.post(\"/strings/add\", response_model=StringOutput, summary=\"Concatenate two strings\", description=\"Accepts two strings as input and returns their concatenation. This endpoint implements the 'add two strings' function.\")\nasync def add_strings(string_input: StringInput):\n    \"\"\"Concatenates two strings and returns the result.\"\"\"\n    try:\n        result = string_input.str1 + string_input.str2\n        return StringOutput(result=result)\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n",
      "frontend": {
        "StringAdder.jsx": "import React, { useState } from 'react';\n\nfunction StringAdder() {\n  const [str1, setStr1] = useState('');\n  const [str2, setStr2] = useState('');\n  const [result, setResult] = useState('');\n  const [error, setError] = useState('');\n\n  const handleSubmit = async (event) => {\n    event.preventDefault();\n\n    try {\n      const response = await fetch('/strings/add', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ str1, str2 }),\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json();\n        setError(errorData.detail || 'An error occurred');\n        setResult('');\n        return;\n      }\n\n      const data = await response.json();\n      setResult(data.result);\n      setError('');\n    } catch (err) {\n      setError(err.message || 'An unexpected error occurred');\n      setResult('');\n    }\n  };\n\n  return (\n    <div>\n      <form onSubmit={handleSubmit}>\n        <div>\n          <label htmlFor=\"str1\">String 1:</label>\n          <input\n            type=\"text\"\n            id=\"str1\"\n            value={str1}\n            onChange={(e) => setStr1(e.target.value)}\n          />\n        </div>\n        <div>\n          <label htmlFor=\"str2\">String 2:</label>\n          <input\n            type=\"text\"\n            id=\"str2\"\n            value={str2}\n            onChange={(e) => setStr2(e.target.value)}\n          />\n        </div>\n        <button type=\"submit\">Add Strings</button>\n      </form>\n      {error && <div style={{ color: 'red' }}>Error: {error}</div>}\n      {result && <div>Result: {result}</div>}\n    </div>\n  );\n}\n\nexport default StringAdder;\n",
        "App.jsx": "import React from 'react';\nimport StringAdder from './StringAdder';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <h1>String Adder</h1>\n      <StringAdder />\n    </div>\n  );\n}\n\nexport default App;"
      },
      "migrations": [
        {
          "migration_name": "create_strings_table",
          "description": "Creates a table for storing strings if needed in the future.",
          "up": [
            {
              "command": "CREATE TABLE strings (",
              "parameters": [
                "id SERIAL PRIMARY KEY",
                "str1 VARCHAR(255)",
                "str2 VARCHAR(255)",
                "result VARCHAR(255)"
              ],
              "command_end": ");"
            }
          ],
          "down": [
            {
              "command": "DROP TABLE IF EXISTS strings;"
            }
          ]
        }
      ]
    }
  },
  "extra": {
    "evaluation_requested": true,
    "evaluation": {
      "enabled": true,
      "rubric": "fullstack_generation_v1",
      "rubric_id": "fullstack_generation_v1",
      "rubric_version": "1.0.0",
      "criteria": [
        {
          "criterion": "objective_tests",
          "raw_score": 85.7143,
          "normalized_score": 0.8571,
          "adjusted_normalized_score": 0.5926,
          "score": 85.71,
          "weight": 0.6,
          "formula_id": "zero_one",
          "critical_floor": 0.7,
          "floor_passed": true,
          "max_score": 100.0
        },
        {
          "criterion": "code_quality",
          "raw_score": 86.0,
          "normalized_score": 0.86,
          "adjusted_normalized_score": 0.5933,
          "score": 86.0,
          "weight": 0.2,
          "formula_id": "zero_one",
          "critical_floor": 0.8,
          "floor_passed": true,
          "max_score": 100.0
        },
        {
          "criterion": "efficiency",
          "raw_score": 45.0,
          "normalized_score": 0.45,
          "adjusted_normalized_score": 0.487,
          "score": 45.0,
          "weight": 0.1,
          "formula_id": "zero_one",
          "critical_floor": null,
          "floor_passed": true,
          "max_score": 100.0
        },
        {
          "criterion": "documentation",
          "raw_score": 74.9,
          "normalized_score": 0.749,
          "adjusted_normalized_score": 0.5646,
          "score": 74.9,
          "weight": 0.1,
          "formula_id": "zero_one",
          "critical_floor": null,
          "floor_passed": true,
          "max_score": 100.0
        }
      ],
      "overall_score": 72.9,
      "weighted_score": 80.62,
      "grade": "F",
      "passed": false,
      "pass_threshold": 70.0,
      "step_scores": [
        {
          "step_name": "design_architecture",
          "status": "success",
          "score": 100.0
        },
        {
          "step_name": "generate_api",
          "status": "success",
          "score": 100.0
        },
        {
          "step_name": "generate_migrations",
          "status": "success",
          "score": 100.0
        },
        {
          "step_name": "generate_frontend",
          "status": "success",
          "score": 100.0
        },
        {
          "step_name": "generate_integration_tests",
          "status": "success",
          "score": 100.0
        },
        {
          "step_name": "review_code",
          "status": "success",
          "score": 100.0
        },
        {
          "step_name": "assemble_feature",
          "status": "skipped",
          "score": 0.0
        }
      ],
      "dataset": {
        "source": "local",
        "dataset_id": "agentic-workflows-v2/tests/fixtures/datasets/code_instructions_120k.json",
        "dataset_path": "agentic-workflows-v2/tests/fixtures/datasets/code_instructions_120k.json",
        "sample_index": 1,
        "task_id": "1",
        "dataset_workflow_compatible": true,
        "dataset_mismatch_reasons": []
      },
      "generated_at": "2026-02-08T21:33:33.161241+00:00",
      "hard_gates": {
        "required_outputs_present": false,
        "overall_status_success": true,
        "no_critical_step_failures": true,
        "schema_contract_valid": true,
        "dataset_workflow_compatible": true
      },
      "hard_gate_failures": [
        "required_outputs_present"
      ],
      "floor_violations": [],
      "grade_capped": false
    }
  }
}