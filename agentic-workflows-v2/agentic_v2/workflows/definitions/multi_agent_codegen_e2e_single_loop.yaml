name: multi_agent_codegen_e2e_single_loop
description: End-to-end multi-agent code generation with build-first gates and a single bounded QA loop
version: "1.0"

capabilities:
  inputs: [feature_spec, repo_context, constraints, quality_bar]
  outputs: [feature_package, release_manifest, final_gate_report, all_code]

evaluation:
  rubric_id: multi_agent_codegen_e2e_single_loop_v1
  scoring_profile: A
  criteria:
    - name: objective_tests
      definition: Objective correctness through static and dynamic test gates.
      evidence_required:
        - Static analysis report
        - Executable test outcomes
      scale:
        "1": Tests fail broadly
        "2": Major objective gaps
        "3": Baseline objective pass
        "4": Strong objective validation
        "5": Excellent objective validation
      weight: 0.45
      critical_floor: 0.75
      formula_id: zero_one
    - name: review_quality
      definition: Code review depth and issue resolution quality.
      evidence_required:
        - Structured review findings
        - Rework evidence
      scale:
        "1": Superficial or incorrect review
        "2": Weak coverage of issues
        "3": Acceptable review quality
        "4": Strong, actionable review
        "5": Comprehensive and precise review
      weight: 0.20
      critical_floor: 0.80
      formula_id: zero_one
    - name: package_integrity
      definition: Final artifact completeness and integration quality.
      evidence_required:
        - Package manifest
        - Integrated backend/frontend/shared artifacts
      scale:
        "1": Package incomplete
        "2": Significant integration defects
        "3": Usable integrated package
        "4": Strong package integrity
        "5": Production-ready package quality
      weight: 0.20
      critical_floor: 0.75
      formula_id: zero_one
    - name: execution_efficiency
      definition: Runtime and iteration efficiency.
      evidence_required:
        - Bounded rework rounds
        - Reasonable retry/latency profile
      scale:
        "1": Excessive retries/latency
        "2": High inefficiency
        "3": Acceptable efficiency
        "4": Good efficiency
        "5": Excellent efficiency
      weight: 0.10
      formula_id: zero_one
    - name: documentation_handoff
      definition: Handoff clarity and release traceability.
      evidence_required:
        - Manifest and handoff notes
      scale:
        "1": Missing handoff quality
        "2": Sparse handoff quality
        "3": Adequate handoff quality
        "4": Clear handoff quality
        "5": Excellent handoff quality
      weight: 0.05
      formula_id: zero_one

inputs:
  feature_spec:
    type: string
    description: Natural language description of desired feature or product increment
  repo_context:
    type: object
    description: Existing repository context, conventions, and constraints
    default: {}
  constraints:
    type: object
    description: Build/runtime/security constraints for generation
    default:
      target_runtime: python
      package_type: fullstack
      max_rework_rounds: 2
      require_tests: true
  quality_bar:
    type: string
    enum: [standard, strict]
    default: standard
    description: Strictness level for final release gate

steps:
  # Phase 1: Problem decomposition and architecture
  - name: decompose_problem
    agent: tier3_planner
    prompt_file: planner.md
    description: Break request into scoped requirements, task graph, and acceptance criteria
    inputs:
      feature_spec: ${inputs.feature_spec}
      repo_context: ${inputs.repo_context}
      constraints: ${inputs.constraints}
    outputs:
      scoped_requirements: scoped_requirements
      acceptance_criteria: acceptance_criteria
      task_graph: task_graph
      iteration_plan: iteration_plan

  - name: design_architecture
    agent: tier3_architect
    prompt_file: architect.md
    description: Produce architecture, contracts, and package layout for implementation
    depends_on: [decompose_problem]
    inputs:
      requirements: ${steps.decompose_problem.outputs.scoped_requirements}
      acceptance_criteria: ${steps.decompose_problem.outputs.acceptance_criteria}
      task_graph: ${steps.decompose_problem.outputs.task_graph}
      constraints: ${inputs.constraints}
      repo_context: ${inputs.repo_context}
    outputs:
      architecture_blueprint: architecture_blueprint
      api_contracts: api_contracts
      data_model: data_model
      package_layout: package_layout

  # Phase 2: Parallel implementation
  - name: implement_backend
    agent: tier2_coder
    prompt_file: coder.md
    description: Implement backend services and API handlers
    depends_on: [design_architecture]
    inputs:
      architecture: ${steps.design_architecture.outputs.architecture_blueprint}
      api_contracts: ${steps.design_architecture.outputs.api_contracts}
      data_model: ${steps.design_architecture.outputs.data_model}
      constraints: ${inputs.constraints}
    outputs:
      backend_code: backend_code
      backend_tests: backend_tests

  - name: implement_frontend
    agent: tier2_coder
    prompt_file: coder.md
    description: Implement frontend flows aligned to API contracts
    depends_on: [design_architecture]
    inputs:
      architecture: ${steps.design_architecture.outputs.architecture_blueprint}
      package_layout: ${steps.design_architecture.outputs.package_layout}
      api_contracts: ${steps.design_architecture.outputs.api_contracts}
      constraints: ${inputs.constraints}
    outputs:
      frontend_code: frontend_code
      frontend_tests: frontend_tests

  - name: implement_shared
    agent: tier2_coder
    prompt_file: developer.md
    description: Implement shared models, types, and utilities
    depends_on: [design_architecture]
    inputs:
      data_model: ${steps.design_architecture.outputs.data_model}
      api_contracts: ${steps.design_architecture.outputs.api_contracts}
      package_layout: ${steps.design_architecture.outputs.package_layout}
    outputs:
      shared_code: shared_code
      shared_tests: shared_tests

  # Phase 3: Test planning and pre-test build gate
  - name: build_test_plan
    agent: tier2_tester
    prompt_file: tester.md
    description: Build layered test plan and explicit quality gates
    depends_on: [decompose_problem, design_architecture]
    inputs:
      acceptance_criteria: ${steps.decompose_problem.outputs.acceptance_criteria}
      architecture: ${steps.design_architecture.outputs.architecture_blueprint}
      constraints: ${inputs.constraints}
      quality_bar: ${inputs.quality_bar}
    outputs:
      test_plan: test_plan
      quality_gates: quality_gates

  - name: generate_integration_tests
    agent: tier2_tester
    prompt_file: tester.md
    description: Generate integration and end-to-end tests from implementation and plan
    depends_on: [implement_backend, implement_frontend, implement_shared, build_test_plan]
    inputs:
      backend: ${steps.implement_backend.outputs.backend_code}
      frontend: ${steps.implement_frontend.outputs.frontend_code}
      shared: ${steps.implement_shared.outputs.shared_code}
      test_plan: ${steps.build_test_plan.outputs.test_plan}
      acceptance_criteria: ${steps.decompose_problem.outputs.acceptance_criteria}
    outputs:
      integration_tests: integration_tests
      e2e_tests: e2e_tests

  - name: static_checks_pretest
    agent: tier1_validator
    prompt_file: validator.md
    description: Run lint, type, and static checks before any test execution
    depends_on: [implement_backend, implement_frontend, implement_shared]
    inputs:
      backend: ${steps.implement_backend.outputs.backend_code}
      frontend: ${steps.implement_frontend.outputs.frontend_code}
      shared: ${steps.implement_shared.outputs.shared_code}
      quality_gates: ${steps.build_test_plan.outputs.quality_gates}
    outputs:
      static_check_report: static_report_pretest
      overall_status: static_status_pretest

  - name: build_verify_pretest
    agent: tier1_validator
    prompt_file: validator.md
    description: Verify artifacts build before test execution
    depends_on: [static_checks_pretest, generate_integration_tests]
    tools: [build_app]
    inputs:
      backend: ${steps.implement_backend.outputs.backend_code}
      frontend: ${steps.implement_frontend.outputs.frontend_code}
      shared: ${steps.implement_shared.outputs.shared_code}
      integration_tests: ${steps.generate_integration_tests.outputs.integration_tests}
      e2e_tests: ${steps.generate_integration_tests.outputs.e2e_tests}
      static_report: ${steps.static_checks_pretest.outputs.static_check_report}
      constraints: ${inputs.constraints}
    outputs:
      build_verification: pretest_build_verification
      ready_for_tests: pretest_ready_for_tests
      failed_phases: pretest_failed_phases

  - name: integration_rework_pretest
    agent: tier2_coder
    prompt_file: developer.md
    description: Integration dev repairs build blockers before tests can run
    depends_on: [build_verify_pretest]
    when: ${steps.build_verify_pretest.outputs.ready_for_tests not in [True, 'true', 'True']}
    inputs:
      backend: ${steps.implement_backend.outputs.backend_code}
      frontend: ${steps.implement_frontend.outputs.frontend_code}
      shared: ${steps.implement_shared.outputs.shared_code}
      integration_tests: ${steps.generate_integration_tests.outputs.integration_tests}
      e2e_tests: ${steps.generate_integration_tests.outputs.e2e_tests}
      static_report: ${steps.static_checks_pretest.outputs.static_check_report}
      build_verification: ${steps.build_verify_pretest.outputs.build_verification}
      failed_phases: ${steps.build_verify_pretest.outputs.failed_phases}
      constraints: ${inputs.constraints}
    outputs:
      backend_code: pretest_backend_code
      frontend_code: pretest_frontend_code
      shared_code: pretest_shared_code
      integration_tests: pretest_integration_tests
      e2e_tests: pretest_e2e_tests
      change_summary: pretest_rework_summary

  - name: build_verify_pretest_after_rework
    agent: tier1_validator
    prompt_file: validator.md
    description: Re-verify build after integration pretest rework
    depends_on: [integration_rework_pretest]
    when: ${steps.integration_rework_pretest.status in ['success', 'SUCCESS']}
    tools: [build_app]
    inputs:
      backend: ${steps.integration_rework_pretest.outputs.backend_code}
      frontend: ${steps.integration_rework_pretest.outputs.frontend_code}
      shared: ${steps.integration_rework_pretest.outputs.shared_code}
      integration_tests: ${steps.integration_rework_pretest.outputs.integration_tests}
      e2e_tests: ${steps.integration_rework_pretest.outputs.e2e_tests}
      constraints: ${inputs.constraints}
    outputs:
      build_verification: pretest_build_verification_after_rework
      ready_for_tests: pretest_ready_for_tests_after_rework
      failed_phases: pretest_failed_phases_after_rework

  # Phase 4: Single bounded QA loop (review + test + rework)
  - name: qa_rework_loop
    agent: tier2_coder
    prompt_file: coder.md
    description: Execute tests, review evidence, and rework code in a bounded loop until approved
    depends_on: [build_verify_pretest, build_verify_pretest_after_rework]
    when: ${coalesce(steps.build_verify_pretest_after_rework.outputs.ready_for_tests, steps.build_verify_pretest.outputs.ready_for_tests) in [True, 'true', 'True']}
    loop_until: ${steps.qa_rework_loop.outputs.review_report.overall_status in ['APPROVED'] and steps.qa_rework_loop.outputs.overall_test_status in ['PASS']}
    loop_max: 2
    inputs:
      backend: ${coalesce(steps.integration_rework_pretest.outputs.backend_code, steps.implement_backend.outputs.backend_code)}
      frontend: ${coalesce(steps.integration_rework_pretest.outputs.frontend_code, steps.implement_frontend.outputs.frontend_code)}
      shared: ${coalesce(steps.integration_rework_pretest.outputs.shared_code, steps.implement_shared.outputs.shared_code)}
      backend_tests: ${steps.implement_backend.outputs.backend_tests}
      frontend_tests: ${steps.implement_frontend.outputs.frontend_tests}
      shared_tests: ${steps.implement_shared.outputs.shared_tests}
      integration_tests: ${coalesce(steps.integration_rework_pretest.outputs.integration_tests, steps.generate_integration_tests.outputs.integration_tests)}
      e2e_tests: ${coalesce(steps.integration_rework_pretest.outputs.e2e_tests, steps.generate_integration_tests.outputs.e2e_tests)}
      acceptance_criteria: ${steps.decompose_problem.outputs.acceptance_criteria}
      quality_gates: ${steps.build_test_plan.outputs.quality_gates}
      static_report: ${steps.static_checks_pretest.outputs.static_check_report}
    outputs:
      backend_code: backend_code_loop
      frontend_code: frontend_code_loop
      shared_code: shared_code_loop
      integration_tests: integration_tests_loop
      e2e_tests: e2e_tests_loop
      review_report: review_report_loop
      test_execution_report: test_report_loop
      overall_test_status: test_status_loop
      failing_tests: failing_tests_loop
      change_summary: loop_change_summary

  # Phase 5: Release packaging and release build gate
  - name: assemble_release_package
    agent: tier1_assembler
    prompt_file: assembler.md
    description: Build release package and manifest from loop-approved artifacts
    depends_on: [qa_rework_loop]
    when: ${steps.qa_rework_loop.outputs.review_report.overall_status in ['APPROVED'] and steps.qa_rework_loop.outputs.overall_test_status in ['PASS']}
    inputs:
      backend: ${coalesce(steps.qa_rework_loop.outputs.backend_code, steps.integration_rework_pretest.outputs.backend_code, steps.implement_backend.outputs.backend_code)}
      frontend: ${coalesce(steps.qa_rework_loop.outputs.frontend_code, steps.integration_rework_pretest.outputs.frontend_code, steps.implement_frontend.outputs.frontend_code)}
      shared: ${coalesce(steps.qa_rework_loop.outputs.shared_code, steps.integration_rework_pretest.outputs.shared_code, steps.implement_shared.outputs.shared_code)}
      integration_tests: ${coalesce(steps.qa_rework_loop.outputs.integration_tests, steps.integration_rework_pretest.outputs.integration_tests, steps.generate_integration_tests.outputs.integration_tests)}
      e2e_tests: ${coalesce(steps.qa_rework_loop.outputs.e2e_tests, steps.integration_rework_pretest.outputs.e2e_tests, steps.generate_integration_tests.outputs.e2e_tests)}
      architecture: ${steps.design_architecture.outputs.architecture_blueprint}
      acceptance_criteria: ${steps.decompose_problem.outputs.acceptance_criteria}
      test_report: ${steps.qa_rework_loop.outputs.test_execution_report}
      static_report: ${steps.static_checks_pretest.outputs.static_check_report}
    outputs:
      package: feature_package
      manifest: release_manifest
      handoff_notes: handoff_notes

  - name: build_verify_release
    agent: tier1_validator
    prompt_file: validator.md
    description: Verify release package is buildable/runnable before final gate
    depends_on: [assemble_release_package]
    tools: [build_app]
    inputs:
      feature_package: ${steps.assemble_release_package.outputs.package}
      release_manifest: ${steps.assemble_release_package.outputs.manifest}
      handoff_notes: ${steps.assemble_release_package.outputs.handoff_notes}
      constraints: ${inputs.constraints}
      quality_bar: ${inputs.quality_bar}
    outputs:
      build_verification: build_verification_release
      ready_for_release: ready_for_release
      failed_phases: failed_phases_release

  - name: integration_rework_release
    agent: tier2_coder
    prompt_file: developer.md
    description: Integration dev repairs package when release build verification fails
    depends_on: [build_verify_release]
    when: ${steps.build_verify_release.outputs.ready_for_release not in [True, 'true', 'True']}
    inputs:
      backend: ${coalesce(steps.qa_rework_loop.outputs.backend_code, steps.implement_backend.outputs.backend_code)}
      frontend: ${coalesce(steps.qa_rework_loop.outputs.frontend_code, steps.implement_frontend.outputs.frontend_code)}
      shared: ${coalesce(steps.qa_rework_loop.outputs.shared_code, steps.implement_shared.outputs.shared_code)}
      integration_tests: ${coalesce(steps.qa_rework_loop.outputs.integration_tests, steps.generate_integration_tests.outputs.integration_tests)}
      e2e_tests: ${coalesce(steps.qa_rework_loop.outputs.e2e_tests, steps.generate_integration_tests.outputs.e2e_tests)}
      release_manifest: ${steps.assemble_release_package.outputs.manifest}
      build_verification: ${steps.build_verify_release.outputs.build_verification}
      failed_phases: ${steps.build_verify_release.outputs.failed_phases}
      quality_bar: ${inputs.quality_bar}
    outputs:
      backend_code: release_backend_code
      frontend_code: release_frontend_code
      shared_code: release_shared_code
      integration_tests: release_integration_tests
      e2e_tests: release_e2e_tests
      change_summary: release_rework_summary

  - name: assemble_release_package_reworked
    agent: tier1_assembler
    prompt_file: assembler.md
    description: Re-assemble release package after release integration rework
    depends_on: [integration_rework_release]
    when: ${steps.integration_rework_release.status in ['success', 'SUCCESS']}
    inputs:
      backend: ${steps.integration_rework_release.outputs.backend_code}
      frontend: ${steps.integration_rework_release.outputs.frontend_code}
      shared: ${steps.integration_rework_release.outputs.shared_code}
      integration_tests: ${steps.integration_rework_release.outputs.integration_tests}
      e2e_tests: ${steps.integration_rework_release.outputs.e2e_tests}
      architecture: ${steps.design_architecture.outputs.architecture_blueprint}
      acceptance_criteria: ${steps.decompose_problem.outputs.acceptance_criteria}
      test_report: ${steps.qa_rework_loop.outputs.test_execution_report}
      static_report: ${steps.static_checks_pretest.outputs.static_check_report}
    outputs:
      package: feature_package_reworked
      manifest: release_manifest_reworked
      handoff_notes: handoff_notes_reworked

  - name: build_verify_release_reworked
    agent: tier1_validator
    prompt_file: validator.md
    description: Re-verify release package after rework
    depends_on: [assemble_release_package_reworked]
    when: ${steps.assemble_release_package_reworked.status in ['success', 'SUCCESS']}
    tools: [build_app]
    inputs:
      feature_package: ${steps.assemble_release_package_reworked.outputs.package}
      release_manifest: ${steps.assemble_release_package_reworked.outputs.manifest}
      handoff_notes: ${steps.assemble_release_package_reworked.outputs.handoff_notes}
      constraints: ${inputs.constraints}
      quality_bar: ${inputs.quality_bar}
    outputs:
      build_verification: build_verification_release_reworked
      ready_for_release: ready_for_release_reworked
      failed_phases: failed_phases_release_reworked

  - name: final_quality_gate
    agent: tier2_validator
    prompt_file: validator.md
    description: Final gate to confirm release quality and readiness
    depends_on: [build_verify_release, build_verify_release_reworked]
    when: ${coalesce(steps.build_verify_release_reworked.outputs.ready_for_release, steps.build_verify_release.outputs.ready_for_release) in [True, 'true', 'True']}
    inputs:
      package: ${coalesce(steps.assemble_release_package_reworked.outputs.package, steps.assemble_release_package.outputs.package)}
      release_manifest: ${coalesce(steps.assemble_release_package_reworked.outputs.manifest, steps.assemble_release_package.outputs.manifest)}
      build_verification: ${coalesce(steps.build_verify_release_reworked.outputs.build_verification, steps.build_verify_release.outputs.build_verification)}
      ready_for_release: ${coalesce(steps.build_verify_release_reworked.outputs.ready_for_release, steps.build_verify_release.outputs.ready_for_release)}
      failed_phases: ${coalesce(steps.build_verify_release_reworked.outputs.failed_phases, steps.build_verify_release.outputs.failed_phases)}
      quality_bar: ${inputs.quality_bar}
      review_report: ${steps.qa_rework_loop.outputs.review_report}
      test_report: ${steps.qa_rework_loop.outputs.test_execution_report}
      static_report: ${steps.static_checks_pretest.outputs.static_check_report}
      handoff_notes: ${coalesce(steps.assemble_release_package_reworked.outputs.handoff_notes, steps.assemble_release_package.outputs.handoff_notes)}
    outputs:
      gate_report: final_gate_report
      release_decision: release_decision

outputs:
  feature_package:
    from: ${coalesce(steps.assemble_release_package_reworked.outputs.package, steps.assemble_release_package.outputs.package)}
  release_manifest:
    from: ${coalesce(steps.assemble_release_package_reworked.outputs.manifest, steps.assemble_release_package.outputs.manifest)}
  final_gate_report:
    from: ${steps.final_quality_gate.outputs.gate_report}
  release_decision:
    from: ${steps.final_quality_gate.outputs.release_decision}
  quality_summary:
    from:
      qa_loop_review: ${steps.qa_rework_loop.outputs.review_report}
      qa_loop_tests: ${steps.qa_rework_loop.outputs.test_execution_report}
      qa_loop_status: ${steps.qa_rework_loop.outputs.overall_test_status}
      pretest_build: ${coalesce(steps.build_verify_pretest_after_rework.outputs.build_verification, steps.build_verify_pretest.outputs.build_verification)}
      release_build: ${coalesce(steps.build_verify_release_reworked.outputs.build_verification, steps.build_verify_release.outputs.build_verification)}
  all_code:
    from:
      backend: ${coalesce(steps.integration_rework_release.outputs.backend_code, steps.qa_rework_loop.outputs.backend_code, steps.integration_rework_pretest.outputs.backend_code, steps.implement_backend.outputs.backend_code)}
      frontend: ${coalesce(steps.integration_rework_release.outputs.frontend_code, steps.qa_rework_loop.outputs.frontend_code, steps.integration_rework_pretest.outputs.frontend_code, steps.implement_frontend.outputs.frontend_code)}
      shared: ${coalesce(steps.integration_rework_release.outputs.shared_code, steps.qa_rework_loop.outputs.shared_code, steps.integration_rework_pretest.outputs.shared_code, steps.implement_shared.outputs.shared_code)}
      integration_tests: ${coalesce(steps.integration_rework_release.outputs.integration_tests, steps.qa_rework_loop.outputs.integration_tests, steps.integration_rework_pretest.outputs.integration_tests, steps.generate_integration_tests.outputs.integration_tests)}
      e2e_tests: ${coalesce(steps.integration_rework_release.outputs.e2e_tests, steps.qa_rework_loop.outputs.e2e_tests, steps.integration_rework_pretest.outputs.e2e_tests, steps.generate_integration_tests.outputs.e2e_tests)}
